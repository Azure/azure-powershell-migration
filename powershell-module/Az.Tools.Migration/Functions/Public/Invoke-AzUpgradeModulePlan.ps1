function Invoke-AzUpgradeModulePlan
{
    <#
    .SYNOPSIS
        Invokes/executes the specified module upgrade plan steps.

    .DESCRIPTION
        Invokes/executes the specified module upgrade plan steps.

        IMPORTANT: This step is destructive and makes file edits according to module upgrade plan. Always ensure that you have
        a backup copy of the source code in question (for example by using source control). There is no 'undo' operation available after this command runs.

        The upgrade plan is generated by running the New-AzUpgradeModulePlan cmdlet.

    .PARAMETER Plan
        Specify the upgrade plan steps to follow. This is usually passed from pipeline input.

    .EXAMPLE
        PS C:\ Find-AzureRmCommandReferences -DirectoryPath 'C:\source\myModule' -AzureRmModuleVersion 6.13.1 | New-AzUpgradeModulePlan -AzModuleVersion 4.2.0 | Invoke-AzUpgradeModulePlan
        Invokes the upgrade plan generated for "myModule".
    #>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = "High")]
    Param
    (
        [Parameter(
            Mandatory=$true,
            ValueFromPipeline=$true,
            HelpMessage='Specify the upgrade plan steps to follow. This is usually passed from pipeline input.')]
        [UpgradePlan]
        $Plan
    )
    Process
    {
        if ($Plan -eq $null -or $Plan.UpgradeSteps.Count -eq 0)
        {
            Write-Verbose -Message "No module upgrade plan steps were provided. No upgrade will be executed."
            return
        }

        if ($PSCmdlet.ShouldProcess("$($Plan.UpgradeSteps.Count) module upgrade steps will be executed and PowerShell files will be edited in place. This action is not reversable."))
        {
            $currentFile = $null
            $currentFileContents = $null

            $fileBatchResults = New-Object -TypeName 'System.Collections.Generic.List[UpgradeResult]'

            for ([int]$i = 0; $i -lt $Plan.UpgradeSteps.Count; $i++)
            {
                $upgradeStep = $Plan.UpgradeSteps[$i]
                $resetFileBuilder = $false

                $result = New-Object -TypeName UpgradeResult
                $result.Step = $upgradeStep
                $fileBatchResults.Add($result)

                try
                {
                    if ($currentFile -eq $null)
                    {
                        Write-Verbose -Message ("[{0}] Reading file contents." -f $upgradeStep.FileName)

                        $currentFile = $upgradeStep.FullPath
                        $fileContents = Get-Content -Path $currentFile -Raw
                        $currentFileContents = New-Object -TypeName System.Text.StringBuilder -ArgumentList $fileContents
                    }

                    Invoke-ModuleUpgradeStep -Step $upgradeStep -FileContent $currentFileContents

                    # on the final upgrade step? or the next step is a different file?
                    # then write/close the currently in-process file.

                    if ($i -eq ($Plan.UpgradeSteps.Count - 1) -or ($Plan.UpgradeSteps[($i + 1)].FullPath) -ne $currentFile)
                    {
                        Write-Verbose -Message ("[{0}] Saving file contents." -f $upgradeStep.FileName)

                        Set-Content -Path $currentFile -Value $currentFileContents.ToString()

                        Out-FileBatchResult -ResultBatch $fileBatchResults -Success $true -Reason "Completed successfully."
                        $resetFileBuilder = $true
                    }
                }
                catch
                {
                    Out-FileBatchResult -ResultBatch $fileBatchResults -Success $false -Reason "A general error has occurred: $_"
                    $resetFileBuilder = $true
                }
                finally
                {
                    if ($resetFileBuilder -eq $true)
                    {
                        $currentFile = $null
                        $currentFileContents = $null
                        $fileBatchResults.Clear()
                    }
                }
            }
        }
    }
}